#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    bat,            sensorNone)
#pragma config(Sensor, I2C_1,  intmotencFL,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  intmotencBL,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  intmotencBR,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  intmotencARM,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  intmotencW,     sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           LeftWrist,     tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port4,           topRight,      tmotorVex393_MC29, openLoop, driveRight, encoderPort, I2C_4)
#pragma config(Motor,  port5,           bottomRight,   tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port6,           topLeft,       tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port7,           bottomLeft,    tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port10,          RightWrist,    tmotorVex393_HBridge, openLoop, encoderPort, I2C_5)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//88888888888888888888888888888  arm  8888888888888888888888888888888888
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
//88888888888888888888888888888    ARM MOVEMENT  8888888888888888888888888888888888
void movearm(int arm, int duration, int holdarm, int holdarmpos)
{
	if (holdarm==0)
	{
		motor[topRight]     = arm;
		motor[bottomRight]  = arm;
		motor[topLeft]      = arm;
		motor[bottomLeft]   = arm;
		//writeDebugStream(" %d",SensorValue[Wrist], " %d");
		//writeDebugStreamLine("holdarm is: %d",holdarm );  // writes the current value of int 'x' to the debug stream
		wait1Msec(duration);
	}

	//the section below commands arm to selected positions.  There is no position hold feature
	//there is no requirement for use of "abs" because count will always be positive if arm
	//is set during initialization of robot (pre auton)
	if (holdarm==1)
	{
		while ((nMotorEncoder[topRight] > (holdarmpos+40)) || (nMotorEncoder[topRight] < (holdarmpos-40)))
		{
			if (nMotorEncoder[topRight]<holdarmpos) //if below selected point, move up toward it at "arm" speed
			{
				motor[topRight]     = arm;
				motor[bottomRight]  = arm;
				motor[topLeft]      = arm;
				motor[bottomLeft]   = arm;
				wait1Msec(80); //select for arm motion smoothness - too big a number will cause arm
				//to move too fast and shoot past mid point
			}
			else if (nMotorEncoder[topRight]>holdarmpos) //if above selected point, move down toward it at "arm" speed
			{
				motor[topRight]     = -arm*2/3; //motion slowed when moving down to prevent overshoot
				motor[bottomRight]  = -arm*2/3;
				motor[topLeft]      = -arm*2/3;
				motor[bottomLeft]   = -arm*2/3;
				wait1Msec(10);
			}
			else // otherwise stop all arm motors
			{
				stoparm();
			}
		}
			stoparm();
		wait1Msec(5);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
//88888888888888888888888888888    WRIST MOVEMENT  8888888888888888888888888888888888

void  movewrist (int wristspd, int duration, int aton, int wristposit)
{
	//int checking=0;//variable to allow checking of delta count check
	int wristspot = 450;
	if (aton==0)
	{
		if (SensorValue[intmotencW] <= wristspot){
			motor[RightWrist] = wristspd*0.6;
			motor[LeftWrist] = wristspd*0.6;
		}
		else if (SensorValue[intmotencW] > wristspot){
			motor[RightWrist] = wristspd;
			motor[LeftWrist] = wristspd;
		}
		//writeDebugStreamLine("wristangle is: %d",SensorValue[wrist] );
		wait1Msec(duration);
	}
	if (aton==1)
	{
		while ((abs(nMotorEncoder[RightWrist]) > (abs(wristposit)+200))||(abs(nMotorEncoder[RightWrist]) < (abs(wristposit)-200)))
		{
			if (nMotorEncoder[RightWrist] > wristposit)
			{
				motor[RightWrist] = wristspd;
				motor[LeftWrist] = wristspd;
				wait1Msec(10);
			}
			if (nMotorEncoder[RightWrist] < wristposit)
			{
				motor[RightWrist] = -wristspd;
				motor[LeftWrist] = -wristspd;
				wait1Msec(10);
			}
			else
			{
				motor[RightWrist] = 0;
				motor[LeftWrist] = 0;
			}
		}
		motor[RightWrist] = 0;
		motor[LeftWrist] = 0;
	}
}
